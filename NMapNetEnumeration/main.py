import os, nmap3, re, threading, time, json

NETWORK1 = 0
NETWORK2 = 1
NUM_MAX_THREADS = 21
THREAD_NOT_FINISHED = 0
THREAD_FINISHED = 1

THREADS_STATE = [THREAD_NOT_FINISHED for i in range(21)] 


def main():

    analizeNetwork(NETWORK1)
    analizeNetwork(NETWORK2)

def parserNmapResult(fileOut):
    res = []
    fResult = open(fileOut, 'r')
    result = str(fResult.readlines())
    regexResult = str(re.findall('[0-9]+/.*/.*//.*///', str(result))).replace('[\'', '').replace('\']', '').split(',')
    
    #Si detecta algun puerto abierto
    if ('/' in str(regexResult)):
        for y in regexResult:
            res.append(y)
            # El nodo es alcanzable y el resultado contiene información
            if ('0 hosts up' in result) == False and ('/' in str(res)) == True:
                for entries in res:
                    portid = entries.split('/')[0].replace(" ", "")
                    state = entries.split('/')[1].replace(" ", "")
                    protocol = entries.split('/')[2].replace(" ", "")
                    service = entries.split('/')[4].replace(" ", "")

                    print(portid, state)
                    return [portid,state,protocol,service]
    


def analizeNetwork(netName):

    # read file
    with open('network-map.json', 'r') as myfile:
        data=myfile.read()

    # parse file
    jsonO = json.loads(data)
    if netName == 0:
        net = jsonO[NETWORK1]['map']
        name = jsonO[NETWORK1]['networkName']
    if netName == 1:
        net = jsonO[NETWORK2]['map']
        name = jsonO[NETWORK2]['networkName']
    nmap = nmap3.Nmap()
    fileOut = open('nmap-analysis' + name + "-" +str(time.localtime(time.time()).tm_mday) + "-" + str(time.localtime(time.time()).tm_mon) + '-tcp' + '.csv', 'w')

    
    for groups in net:
        group = groups['group']
        fileOut.write('%s\n' % (group))
        analizeGroups(groups, fileOut, nmap)
            

    fileOut.close()

def analizeGroups(groups, fileOut, nmap):
    for host in groups['hosts']:
        hostname = host['hostname']
        ipAddr  =  host['ipAddr']
        service = 'unknown'
        portid = 'unknown'
        protocol = 'unknown'
        print('Host: %s' % ipAddr)
        print('----------------------------------------------------')
        if os.path.exists('Result') == False:
            os.mkdir('Result')
        threads = list()
        portIni = 0   
        for i in range(20):
            #print('PortIni: ' + str(portIni) + ' PortEnd: ' + str(portIni + 3000))
            t = threading.Thread(target=runNmap, args=(ipAddr, portIni, portIni + 3000, i))
            portIni += 3001
            threads.append(t)

        #Añadir ultimo thread los restantes
        #print('PortIni: ' + str(60000) + ' PortEnd: ' + str(65535))
        t = threading.Thread(target=runNmap, args=(ipAddr, 60000, 65535, 20))
        threads.append(t)
        for t in threads:
            t.start()
        for t in threads:
            t.join()
        res = []
        for i in range(21):
            fResult = open('Result' + '/out-' + str(i) + '.txt', 'r')
            result = str(fResult.readlines())
            regexResult = str(re.findall('[0-9]+/.*/.*//.*///', result)).replace('[\'', '').replace('\']', '').split(',')
            #Si detecta algun puerto abierto
            if ('/' in str(regexResult)):
                for y in regexResult:
                    res.append(y)

        portsWroten = []
        # El nodo es alcanzable y el resultado contiene información
        if ('0 hosts up' in result) == False and ('/' in str(res)) == True:
            for entries in res:
                required = False
                
                portid = entries.split('/')[0].replace(" ", "")
                state = entries.split('/')[1].replace(" ", "")
                protocol = entries.split('/')[2].replace(" ", "")
                service = entries.split('/')[4].replace(" ", "")
                
                for entriesNetConfig in host['ports']:
                    if ((entriesNetConfig['portid'] == portid) and (entriesNetConfig['protocol'] == protocol)):
                        required = True
                        if state == "open" or  state == "open|filtered" or state == "filtered": #Protocolo requerido y abierto
                            fileOut.write('%s [%s];%s;%s (%s) [%s];%s;%s\n' % (hostname, ipAddr, service, portid, protocol, state, 'Si', 'Si'))
                            portsWroten.append(portid)

                # Protocolo no requerido pero abierto o filtered
                if required == False:
                    if (state == "open" or  state == "open|filtered" or  state == "filtered"):
                        fileOut.write('%s [%s];%s;%s (%s) [%s];%s;%s\n' % (hostname, ipAddr, service, portid, protocol, state,'No', 'Si'))
                        portsWroten.append(portid)

            #Se comprueba que todos los requeridos se hayan analizado y de no ser asi se checkean individualmente
            for entriesNetConfig in host['ports']:
                #print(entriesNetConfig, portsWroten)
                if (entriesNetConfig['portid'] in portsWroten) == False:
                    os.system('nmap -sT -sU -sV -p%s -n -Pn %s -oG %s/out-%s.txt'  % (entriesNetConfig['portid'], ipAddr, 'Result', 'Required'))
                    fResult = open('Result' + '/out-' + 'Required' + '.txt', 'r')
                    result = str(fResult.readlines())
                    regexResult = str(re.findall('[0-9]+/.*/.*//.*///', result)).replace('[\'', '').replace('\']', '').split(',')
    
                    state = regexResult[0].split('/')[1].replace(" ", "")
                    if(state == 'filtered' or state == 'open|filtered' or state == 'open' ):
                        fileOut.write('%s [%s];%s;%s (%s) [%s];%s;%s\n' % (hostname, ipAddr, entriesNetConfig['portname'], entriesNetConfig['portid'], entriesNetConfig['protocol'], state,'Si', 'Si'))
                    else:
                        fileOut.write('%s [%s];%s;%s (%s) [%s];%s;%s\n' % (hostname, ipAddr, entriesNetConfig['portname'], entriesNetConfig['portid'], entriesNetConfig['protocol'], state,'Si', 'No'))
                   
        else: # El nodo no es alcanzable se refleja en el excel
            print('El host es inalcanzable o no se ha encontrad ningún puerto abierto')
            #Se comprueba que todos los requeridos se hayan analizado y de no ser asi se marcan como que NMAP no los detecta como OPEN
            for entriesNetConfig in host['ports']:
                print(entriesNetConfig, portsWroten)
                if (entriesNetConfig['portid'] in portsWroten) == False:
                    fileOut.write('%s [%s];%s;%s (%s);%s;%s\n' % (hostname, ipAddr, entriesNetConfig['portname'], entriesNetConfig['portid'], entriesNetConfig['protocol'], 'Si', 'No'))

def runNmap(ipAddr, portIni, portEnd, thread):
    os.system('nmap -sU -sS -p%s-%s -n -Pn --min-rate 1000 %s -oG %s/out-%s.txt'  % (portIni, portEnd, ipAddr, 'Result', thread))
    THREADS_STATE[thread] = 1
    printThreadsState()

def printThreadsState():
    index = 0
    for thread in THREADS_STATE:
        if thread == 0:
            print('Thread #%s state\t................... %s' %(index, "RUNNING"))
        else:
            print('Thread #%s state\t................... %s' %(index, "FINISHED"))
        index += 1

def parserNmapResult(fileOut):
    res = []
    fResult = open(fileOut, 'r')
    result = str(fResult.readlines())
    regexResult = str(re.findall('[0-9]+/.*/.*//.*///', str(result))).replace('[\'', '').replace('\']', '').split(',')
    
    #Si detecta algun puerto abierto
    if ('/' in str(regexResult)):
        for y in regexResult:
            res.append(y)
            # El nodo es alcanzable y el resultado contiene información
            if ('0 hosts up' in result) == False and ('/' in str(res)) == True:
                for entries in res:
                    portid = entries.split('/')[0].replace(" ", "")
                    state = entries.split('/')[1].replace(" ", "")
                    protocol = entries.split('/')[2].replace(" ", "")
                    service = entries.split('/')[4].replace(" ", "")
                    return [portid,state,protocol,service]
    return None

if __name__ == "__main__":
    main()